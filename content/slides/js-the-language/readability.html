<section>
  <h3>Readability <span class="pager">(1/7)</span></h3>
  <p class="fragment">
    Use string interpolation instead of concatenation with <em>template literals</em
    ><sup class="es-version">ES2015</sup>:
    <div class="row fragment">
      <pre class="col border-bad"><code data-trim class="js">
        // concatenation
        const a = 1;
        const b = 'a equals ' + a + '.';

        b;  // 'a equals 1.'
      </code></pre>
      <pre class="col border-good"><code data-trim class="js">
        // interpolation
        const a = 1;
        const b = `a equals ${a}.`;

        b;  // 'a equals 1.'
      </code></pre>
    </div>
  </p>
</section>

<section>
  <h3>Readability <span class="pager">(2/7)</span></h3>
  <p>In objects…</p>
  <ul>
    <li>
      when key and value have the same name, use <em>property shorthand</em><sup class="es-version">ES2015</sup>:
      <div class="row">
        <pre class="col border-bad fragment"><code data-trim class="js">
          const a = 1, b = 2;
          const o = { a: a, b: b };
        </code></pre>
        <pre class="col border-good fragment"><code data-trim class="js">
          const a = 1, b = 2;
          const o = { a, b };
        </code></pre>
      </div>
    </li>
    <li class="fragment">
      use <em>method shorthand</em><sup class="es-version">ES2015</sup>:
      <div class="row">
        <pre class="col border-bad fragment"><code data-trim class="js">
          const o = {
            a: function(b, c) {}
          };
        </code></pre>
        <pre class="col border-good fragment"><code data-trim class="js">
          const o = {
            a(b, c) {}
          };
        </code></pre>
      </div>
    </li>
    <li class="fragment">
      when needed, use <em>computed property names</em><sup class="es-version">ES2015</sup>:
      <div class="row">
        <pre class="col border-bad fragment"><code data-trim class="js">
          const a = 'computed';
          const o = {};
          o[a] = 1;
          </code></pre>
        <pre class="col border-good fragment"><code data-trim class="js">
          const a = 'computed';
          const o = { [a]: 1 };
          </code></pre>
      </div>
    </li>
  </ul>
</section>

<section>
  <h3>Readability <span class="pager">(3/7)</span></h3>
  <ul>
    <li>
      Functions can have <em>default parameters</em><sup class="es-version">ES2015</sup>:
      <div class="row">
        <pre class="col border-bad fragment"><code data-trim class="js">
          const a = (b) => {
            b = b || 1;
            return b;
          }

          a();  // 1
        </code></pre>
        <pre class="col border-good fragment"><code data-trim class="js">
          const a = (b = 1) => b




          a();  // 1
        </code></pre>
      </div>
    </li>
    <li class="fragment">
      ⚠️ It only works with <code>undefined</code>:
      <pre class="col"><code data-trim class="js">
        const a = (b = 1) => b

        a(0);         // 0
        a(null);      // null
        a(undefined); // 1
      </code></pre>
    </li>
  </ul>
</section>

<section>
  <h3>Readability <span class="pager">(4/7)</span></h3>
  <ul>
    <li>
      It's possible to <em>destructure</em><sup class="es-version">ES2015</sup> properties from objects:
      <div class="row">
        <pre class="col fragment border-bad"><code data-trim class="js">
          const o = { a: 1, nested: { b: 2 } };
          const a = o.a;
          const b = o.nested.b;
          a;  // 1
          b;  // 2
        </code></pre>
        <pre class="col fragment border-good"><code data-trim class="js">
          const o = { a: 1, nested: { b: 2 } };
          const { a, nested: { b } } = o;

          a;  // 1
          b;  // 2
        </code></pre>
      </div>
    </li>
    <li class="fragment">
      <div class="row">
        <div class="col">
          With default values:
          <pre><code data-trim class="js">
            const o = { a: 1 };
            const { a, b = 2 } = o;
            a;  // 1
            b;  // 2
          </code></pre>
        </div>
        <div class="col fragment">
          With arrays:
          <pre><code data-trim class="js">
            const arr = [1, 2];
            const [a, b] = arr;
            a;  // 1
            b;  // 2
          </code></pre>
        </div>
      </div>
    </li>
    <li class="fragment">
      With function parameters <small>(and default values)</small>:
      <pre><code data-trim class="js">
        const fn = ({ a, b, c = 3 }) = ({ a, b, c });
        fn({ a: 1, b: 2 }); // { a: 1, b: 2, c: 3 }
      </code></pre>
    </li>
  </ul>
</section>

<section>
  <h3>Readability <span class="pager">(5/7)</span></h3>
  <ul>
    <li>
      With <em>rest parameters</em><sup class="es-version">ES2015</sup> any number of arguments are stored in an array:
      <pre class="fragment"><code data-trim class="js">
        const a = (...args) => args;
        a();      // []
        a(1, 2);  // [1, 2]
      </code></pre>
    </li>
    <li class="fragment">
      With the <em>spread operator</em><sup class="es-version">ES2015</sup> any <em>iterable</em><sup class="es-version">ES2015</sup> <small>(arrays, strings and more)</small> can be "spread" into its distinct values:
      <div class="row">
        <pre class="col fragment"><code data-trim class="js">
          // copy array
          const a = [1, 2, 3];
          const b = [...a];
          b;        // [1, 2, 3]
          a === b;  // false
        </code></pre>
        <pre class="col fragment"><code data-trim class="js">
          // concat arrays
          const a = [2, 3];
          const b = [1, ...a, 4];
          b;  // [1, 2, 3, 4]
        </code></pre>
      </div>
    </li>
  </ul>
</section>

<section>
  <h3>Readability <span class="pager">(6/7)</span></h3>
  <p>
    The spread operator also works with objects<sup class="es-version">ES2018</sup>:
    <div class="row">
      <pre class="col fragment"><code data-trim data-line-numbers="1-6|1-12|all" class="js">
        // copy object
        const o1 = {
          a: 1,
          b: { c: 3 },
        };
        const o2 = { ...o1 };

        o2;     // {
                //    a: 1,
                //    b: { c: 3 }
                // }
        o1 === o2;      // false

        // no deep copy:
        o1.c === o2.c;  // true
      </code></pre>
      <pre class="col fragment"><code data-trim data-line-numbers="1-10|all" class="js">
        // merge objects
        const o1 = {
          a: 1,
          b: 2,
        };
        const o2 = {
          ...o1,
          a: 3,
          c: 4,
        };
        o2; // {
            //    a: 3,
            //    b: 2,
            //    c: 4,
            // }
      </code></pre>
    </div>
  </p>
</section>

<section>
  <h3>Readability <span class="pager">(7/7)</span></h3>
  <ul class="stretch">
    <li>
      Prefer <strong>declarative</strong> <code>Array.prototype</code> methods over <strong>imperative</strong> loops:
      <div class="row">
        <pre class="col fragment border-bad"><code data-trim class="js">
          const a = [1, 2, 3];
          let b = [];
          for (const i = 0; i < a.length; i++) {
            b[i] = a[i] * 2;
          }
          b;  // [2, 4, 6]
        </code></pre>
        <pre class="col fragment border-good"><code data-trim class="js">
          const a = [1, 2, 3];
          const b = a.map((item) => item * 2);



          b;  // [2, 4, 6]
        </code></pre>
      </div>
    </li>
    <li class="fragment">
      More examples:
      <div class="row">
        <pre class="col"><code data-trim class="js">
          const a = [1, 2, 3];
          // filter items:
          const b = a.filter((item) => item > 2);
          b;  // [3];
        </code></pre>
        <pre class="col fragment"><code data-trim class="js">
          const a = [1, 2, 3];
          // find item:
          const b = a.find((item) => item === 2);
          b;  // 2;
        </code></pre>
      </div>
      <div class="row">
        <pre class="col fragment"><code data-trim class="js">
          const a = [1, 2, 3];
          // check if all items satisfy a condition:
          const b = a.every((item) => item > 2);
          b;  // false;
        </code></pre>
        <pre class="col fragment"><code data-trim class="js">
          const a = [1, 2, 3];
          // reduce to a single value:
          const b = a.reduce((acc, item) => acc + item, 0);
          b;  // 6;
        </code></pre>
      </div>
    </li>
  </ul>
</section>
