<section data-theme="yellow">
  <h1>JS</h1>
  <h2>readability</h2>
</section>

<section>
  <h3>String interpolation <span class="pager">(1/11)</span></h3>
  <p class="fragment">
    Use string interpolation instead of concatenation with <em>template literals</em
    ><sup class="es-version">ES2015</sup>:
    <div class="row fragment">
      <pre class="col border-bad"><code data-trim class="js">
        // concatenation
        const a = 1;
        const b = 'a equals ' + a + '.';

        b;  // 'a equals 1.'
      </code></pre>
      <pre class="col border-good"><code data-trim class="js">
        // interpolation
        const a = 1;
        const b = `a equals ${a}.`;

        b;  // 'a equals 1.'
      </code></pre>
    </div>
  </p>
</section>

<section>
  <h3>Default values <span class="pager">(2/11)</span></h3>
  <ul>
    <li>
      Functions can have <em>default parameters</em><sup class="es-version">ES2015</sup>:
      <div class="row">
        <pre class="col border-bad fragment"><code data-trim class="js">
          const a = (b) => {
            b = b || 1;
            return b;
          }

          a();  // 1
        </code></pre>
        <pre class="col border-good fragment"><code data-trim class="js">
          const a = (b = 1) => b




          a();  // 1
        </code></pre>
      </div>
    </li>
    <li class="fragment">
      ⚠️ It only works with <code>undefined</code>:
      <pre><code data-trim class="js">
        const a = (b = 1) => b

        a(0);         // 0
        a(null);      // null
        a(undefined); // 1
      </code></pre>
    </li>
  </ul>
</section>

<section>
  <h3>Object literals <span class="pager">(3/11)</span></h3>
  <p>In objects…</p>
  <ul>
    <li>
      when key and value have the same name, use <em>property shorthand</em><sup class="es-version">ES2015</sup>:
      <div class="row">
        <pre class="col border-bad fragment"><code data-trim class="js">
          const a = 1, b = 2;
          const o = { a: a, b: b };
        </code></pre>
        <pre class="col border-good fragment"><code data-trim class="js">
          const a = 1, b = 2;
          const o = { a, b };
        </code></pre>
      </div>
    </li>
    <li class="fragment">
      use <em>method shorthand</em><sup class="es-version">ES2015</sup>:
      <div class="row">
        <pre class="col border-bad fragment"><code data-trim class="js">
          const o = {
            a: function(b, c) {}
          };
        </code></pre>
        <pre class="col border-good fragment"><code data-trim class="js">
          const o = {
            a(b, c) {}
          };
        </code></pre>
      </div>
    </li>
    <li class="fragment">
      when needed, use <em>computed property names</em><sup class="es-version">ES2015</sup>:
      <div class="row">
        <pre class="col border-bad fragment"><code data-trim class="js">
          const a = 'computed';
          const o = {};
          o[a] = 1;
          </code></pre>
        <pre class="col border-good fragment"><code data-trim class="js">
          const a = 'computed';
          const o = { [a]: 1 };
          </code></pre>
      </div>
    </li>
  </ul>
</section>

<section>
  <h3>Nested property lookup <span class="pager">(4/11)</span></h3>
  <p>When you have an object with possibly nested properties, use <em>optional chaining</em><sup class="es-version glow">ES2020</sup>:</p>
  <div class="row">
    <pre class="col fragment border-bad"><code data-trim data-line-numbers="1-3|1-7|all" class="js">
      const findProp = (o) => {
        return o && o.a && o.a.b && o.a.b.c;
      }

      findProp();           // undefined
      findProp({ a: {} });  // undefined
      findProp({ a: { b: { c: 1 } } }); // 1

      // works with falsy values:
      findProp({ a: 0 });   // 0
    </code></pre>
    <pre class="col fragment border-good"><code data-trim data-line-numbers="1-3|1-7|all" class="js">
      const findProp = (o) => {
        return o?.a?.b?.c;
      }

      findProp();           // undefined
      findProp({ a: {} });  // undefined
      findProp({ a: { b: { c: 1 } } }); // 1

      // ⚠️ only works with null and undefined:
      findProp({ a: 0 });   // undefined
    </code></pre>
  </div>
</section>

<section>
  <h3>Destructuring <span class="pager">(5/11)</span></h3>
  <ul>
    <li>
      It's possible to <em>destructure</em><sup class="es-version">ES2015</sup> properties from objects:
      <div class="row">
        <pre class="col fragment border-bad"><code data-trim class="js">
          const o = { a: 1, nested: { b: 2 } };
          const a = o.a;
          const b = o.nested.b;
          a;  // 1
          b;  // 2
        </code></pre>
        <pre class="col fragment"><code data-trim class="js">
          const o = { a: 1, nested: { b: 2 } };
          const { a, nested: { b } } = o;

          a;  // 1
          b;  // 2
        </code></pre>
      </div>
    </li>
    <li class="fragment">
      <div class="row">
        <div class="col">
          With default values:
          <pre><code data-trim class="js">
            const o = { a: 1 };
            const { a, b = 2 } = o;
            a;  // 1
            b;  // 2
          </code></pre>
        </div>
        <div class="col fragment">
          With arrays:
          <pre><code data-trim class="js">
            const arr = [1, 2];
            const [a, b] = arr;
            a;  // 1
            b;  // 2
          </code></pre>
        </div>
      </div>
    </li>
    <li class="fragment">
      With function parameters <small>(and default values)</small>:
      <pre><code data-trim class="js">
        const fn = ({ a, b, c = 3 }) => ({ a, b, c });
        fn({ a: 1, b: 2 }); // { a: 1, b: 2, c: 3 }
      </code></pre>
    </li>
  </ul>
</section>

<section>
  <h3>Rest/spread operator <span class="pager">(6/11)</span></h3>
  <ul>
    <li>
      With <em>rest parameters</em><sup class="es-version">ES2015</sup> any number of arguments are stored in an array:
      <pre class="fragment"><code data-trim class="js">
        const a = (...args) => args;
        a();      // []
        a(1, 2);  // [1, 2]
      </code></pre>
    </li>
    <li class="fragment">
      With the <em>spread operator</em><sup class="es-version">ES2015</sup> any <em>iterable</em><sup class="es-version">ES2015</sup> <small>(arrays, strings and more)</small> can be "spread" into its distinct values:
      <div class="row">
        <pre class="col fragment"><code data-trim class="js">
          // copy array
          const a = [1, 2, 3];
          const b = [...a];
          b;        // [1, 2, 3]
          a === b;  // false
        </code></pre>
        <pre class="col fragment"><code data-trim class="js">
          // concat arrays
          const a = [2, 3];
          const b = [1, ...a, 4];
          b;  // [1, 2, 3, 4]
        </code></pre>
      </div>
    </li>
  </ul>
</section>

<section>
  <h3>Object rest and spread <span class="pager">(7/11)</span></h3>
  <ul>
    <li>
      The rest operator can be used in object destructuring<sup class="es-version">ES2018</sup>:
      <pre class="fragment"><code data-trim class="js">
        const o = { a: 1, b: 2, c: 3 };
        const { a, ...rest } = o;
        a;    // 1
        rest; // { b: 2, c: 3 }
      </code></pre>
    </li>
    <li class="fragment">
      The spread operator also works with objects<sup class="es-version">ES2018</sup>:
      <div class="row">
        <pre class="col fragment"><code data-trim data-line-numbers="1-6|1-12|all" class="js">
          // copy object
          const o1 = {
            a: 1,
            b: { c: 3 },
          };
          const o2 = { ...o1 };

          o2;         // {
                      //    a: 1,
                      //    b: { c: 3 }
                      // }
          o1 === o2;  // false

          // no deep copy:
          o1.b === o2.b;  // true
        </code></pre>
        <pre class="col fragment"><code data-trim data-line-numbers="1-10|all" class="js">
          // merge objects
          const o1 = {
            a: 1,
            b: 2,
          };
          const o2 = {
            ...o1,
            a: 3,
            c: 4,
          };
          o2; // {
              //    a: 3,
              //    b: 2,
              //    c: 4,
              // }
        </code></pre>
      </div>
    </li>
  </ul>
</section>

<section>
  <h3>Object "iteration" <span class="pager">(8/11)</span></h3>
  <ul>
    <li>
      It's possible to iterate over object properties by converting to an array:
      <pre class="fragment"><code data-trim data-noescape class="js">
        const o = { a: 1, b: 2, c: 3 };

        Object.keys(o);     // ['a', 'b', 'c']
        Object.values(o);   // [1, 2, 3]
        Object.entries(o);  // [['a', 1], ['b', 2], ['c', 3]]
        <span class="es-version glow" style="position: absolute; transform: translate(-110%, -1.5em) rotate(-35deg);">ES2017</span>
      </code></pre>
    </li>
    <li class="fragment">
      The result of <code>Object.entries()</code> can be converted back to an object:
      <pre class="fragment"><code data-trim class="js">
        const a = [['a', 1], ['b', 2], ['c', 3]];
        Object.fromEntries(a);  // { a: 1, b: 2, c: 3 }
      </code></pre>
    </li>
  </ul>
</section>

<section>
  <h3><code>Array.prototype</code> <span class="pager">(9/11)</span></h3>
  <ul class="stretch">
    <li>
      Prefer <strong>declarative</strong> <code>Array.prototype</code> methods over <strong>imperative</strong> loops:
      <div class="row">
        <pre class="col fragment border-bad"><code data-trim class="js">
          const a = [1, 2, 3];
          let b = [];
          for (const i = 0; i < a.length; i++) {
            b[i] = a[i] * 2;
          }
          b;  // [2, 4, 6]
        </code></pre>
        <pre class="col fragment border-good"><code data-trim class="js">
          const a = [1, 2, 3];
          const b = a.map((item) => item * 2);



          b;  // [2, 4, 6]
        </code></pre>
      </div>
    </li>
    <li class="fragment">
      More examples:
      <div class="row">
        <pre class="col"><code data-trim class="js">
          const a = [1, 2, 3];
          // filter items:
          const b = a.filter((item) => item > 2);
          b;  // [3];
        </code></pre>
        <pre class="col fragment"><code data-trim class="js">
          const a = [1, 2, 3];
          // find item:
          const b = a.find((item) => item === 2);
          b;  // 2;
        </code></pre>
      </div>
      <div class="row">
        <pre class="col fragment"><code data-trim class="js">
          const a = [1, 2, 3];
          // check if any item satisfies condition:
          const b = a.some((item) => item > 2);
          b;  // true;
        </code></pre>
        <pre class="col fragment"><code data-trim class="js">
          const a = [1, 2, 3];
          // check if all items satisfy condition:
          const b = a.every((item) => item > 2);
          b;  // false;
        </code></pre>
      </div>
    </li>
  </ul>
</section>

<section>
  <h3>More <code>Array.prototype</code> <span class="pager">(10/11)</span></h3>
  <ul class="stretch">
    <li>
      <pre><code data-trim class="js">
        const a = [1, 2, 3];
        // check if primitive is present:
        const b = a.includes(3);
        b;  // true;
      </code></pre>
    </li>
    <li class="fragment">
      <pre><code data-trim class="js">
        const a = [1, 2, 3];
        // reduce to a single value:
        const b = a.reduce((acc, item) => acc + item, 0);
        b;  // 6;
      </code></pre>
    </li>
    <li class="fragment">
      <div class="row">
        <div class="col">
          <pre><code data-trim data-noescape class="js">
            const a = [[1, 2], [[3], [4, 5]]];
            <span class="fragment"><span class="es-version glow" style="position: absolute; transform: translate(-110%, 4em) rotate(-35deg);">ES2019</span>
            // flatten array 1 level:
            const b = a.flat();
            b;  // [1, 2, [3], [4, 5]];</span>
            <span class="fragment">
            // flatten array 2 levels:
            const c = a.flat(2);
            c;  // [1, 2, 3, 4, 5];</span>
          </code></pre>
        </div>
        <div class="col fragment">
          <pre><code data-trim data-noescape class="js">
            const a = [
              { numbers: [1, 2, 3] },
              { numbers: [4, 5] },
            ];
            <span class="fragment">
            // get numbers with map:
            const b = a.map((item) => item.numbers);
            b;  // [[1, 2, 3], [4, 5]];</span>
            <span class="fragment"><span class="es-version glow" style="position: absolute; transform: translate(-110%, 4em) rotate(-35deg);">ES2019</span>
            // get numbers with flatMap:
            const c = a.flatMap((item) => item.numbers);
            c;  // [1, 2, 3, 4, 5];</span>
          </code></pre>
        </div>
      </div>
    </li>
  </ul>
</section>

<section>
  <h3><code>Map</code> and <code>Set</code> <span class="pager">(11/11)</span></h3>
  <div class="row">
    <div class="col">
      <p>A <code>Set</code><sup class="es-version">ES2015</sup> is similar to an <em>array</em>:</p>
      <pre class="fragment"><code data-trim data-line-numbers="1-2|1-8|all" class="js">
        const a = new Set([1, 2, 3]);
        a;            // Set(3) {1, 2, 3}

        // different API than array:
        a.size;       // 3
        a.has(2);     // true
        a.add(4);     // Set(4) {1, 2, 3, 4}
        a.delete(4);

        // items are unique:
        const b = new Set(['a', 'a', 'b']);
        b;            // Set(2) {'a', 'b'}
      </code></pre>
    </div>
    <div class="col fragment">
      <p>A <code>Map</code><sup class="es-version">ES2015</sup> is similar to an <em>object literal</em>:</p>
      <pre class="fragment"><code data-trim data-line-numbers="1-2|1-9|all" class="js">
        const a = new Map([['a', 1], ['b', 2]]);
        a;  // Map(2) {'a' => 1, 'b' => 2}

        // different API than object literal:
        a.size;       // 2
        a.has('a');   // true
        a.get('b');   // 2
        a.set('c', 3);
        a.delete('c');

        // keys can be any value:
        const b = new Map();
        b.set({ a: 1 }, 'a');
        b.set([1, 2], 'b');
      </code></pre>
      <small class="fragment">Performs better when key/value pairs are frequently added/removed.</small>
    </div>
  </div>
</section>
